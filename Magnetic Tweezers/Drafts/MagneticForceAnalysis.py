#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Nov 10 09:50:31 2021

@author: bizzaro
"""

'''
SATURDAY:  implment N matrix for simiplicity.

if time allows: figure out why we are not in pico N
also, get a double checker.



MAGNETIC FORCE ANALYSIS / MAGNETIC MONOPOLE APPROXIMATION / LUMPED-ELEMENT MODEL

    The lumped-element model (also called lumped-parameter model, or 
    lumped-component model) simplifies the description of the 
    behaviour of spatially distributed physical systems into
    a topology consisting of discrete entities that approximate 
    the behaviour of the distributed system under certain assumptions.
    It is useful in electrical systems (including electronics), 
    mechanical multibody systems, heat transfer, acoustics, etc.

    When viewing magnetic poles of the tweezers from the workspace, 
    they are sharp tips and generate a magnetic field that looks to 
    the magnetic particle as though it is generated by point sources. 
    Magnetic monopole approximation [25], [30] is there- fore employed 
    in this analysis to model the magnetic field gen- erated by the 
    quadrupole magnetic tweezers in the workspace. In this model, 
    the magnetic field generated by each magnetic pole is approximated 
    by the field of a point magnetic charge associated with the magnetic 
    pole, and the total magnetic field produced by the system is obtained 
    by applying the principle of superposition. Although a magnetic monopole 
    is a hypothetical point source, this approximation greatly simplifies the 
    process of modeling and yields an expression of the magnetic field in 
    the workspace similar to that of an electric field.More importantly,this 
    expression enables us later to derive a compact analytical force
    model that accurately characterizes the nonlinearity of the magnetic 
    force exerting on the magnetic particle with respect to the applied 
    currents to the coils and the position dependency of the magnetic 
    force in the workspace.

    When a magnetic particle is placed inside a magnetic field, 
    it will be magnetized, and in turn alter its surrounding magnetic field. 
    The magnetic force experienced by the magnetic particle is then determined 
    by the particleâ€™s magnetization and the altered field. To calculate the 
    magnetic force using the original magnetic field, the effective magnetization 
    of the particle should be used. For a spherical par- ticle, 
    its effective magnetization is proportional to the external magnetic field [31] 
    until the magnetization saturates.
'''
import numpy as np
import matplotlib.pyplot as plt
plt.rcParams["figure.figsize"]=(8, 8)


milli = (10**(-3))
micro = (10**(-6))
nano = (10**(-9))
pico = (10**(-12))


##################################################################################################################
#%%
#System Properties
#INPUTS TO SYSTEM

perm0 = ((4*np.pi)*(10**(-7)))
measurement_location = [400*micro,0*micro]         # microbot position of interest


ILeft = 0                                           # Applied current to left coil/pole in Amps
ITop = 0                                           # Applied current to top coil/pole in Amps
IRight = 1                                       # Applied current to right coil/pole in Amps
IBottom = 0                                         # Applied current to bottom coil/pole in Amps          
               




#System Properties
Pole_Pole_Distance = 980 * micro                   # pole to pole distance in um, defines workspace area
L = (Pole_Pole_Distance/2)                         # length to center of workspace
Gradient_Space = (L/4)                             # Maximum gradient estimation distance 
I_max = .9                                         # Maximum current to avoid pole saturation --> value taken from paper
NTurns = 21                                        # number of turns on a single coil --> taken from paper
reluctance = (1.8*(10**9))                        # magnetic resitance of air gap --> value from paper 



#MICROSPHERE PROPERTIES
Bead_Diameter = (2.8 *micro)                       # bead diameter in micrometers
perm_bead = .0000375                               # neglected for force calculations: see "magnetic coeffceitns for why"
Volume = ((4/3)*np.pi*((Bead_Diameter/2)**3))      # volume of microsphere



#This wont really change anything
Air_AreaC = (0.18*milli*milli)                     # cross sectioal area of air gap 


#grid resolution of magnetic streamlines
gridp = 10




##################################################################################################################
#%%
Perm_coef = 1#((perm_bead - perm0)/(perm_bead + (2*perm0)))

km = (perm0/(4*np.pi))
kQ = ((3*Volume*(km**2))/(2*perm0*(L**5))) * Perm_coef #coefficient related to the properties of the magnetic particle and themagnetic tweezers
ki = (kQ * ((NTurns/(perm0*reluctance))**2)) #lumped coefficent related to the particle and magnetic curcuit properites
ki_hat = (ki * (I_max**2))

print("Ki = ", ki)
print("Ki_hat = ", ki_hat,"\n\n")


##################################################################################################################
#%%
Left_Pole_Origin = [-Pole_Pole_Distance/2,0]
Top_Pole_Origin = [0,Pole_Pole_Distance/2]
Right_Pole_Origin = [Pole_Pole_Distance/2,0]
Bottom_Pole_Origin = [0,-Pole_Pole_Distance/2]




def r_vector(pole_pos, measurement_location):
    '''
    returns a 2D array fector in direction of microbot from desired pole
    '''
    x1 = pole_pos[0]
    y1 = pole_pos[1]
    
    x2 = measurement_location[0]
    y2 = measurement_location[1]
    r_vector = np.array([(x2-x1),(y2-y1)])
 
    return r_vector

def r_distance(pole_pos, measurement_location):
    '''
    returns a scalar distance desired pole to microbot
    not the normalized sistance r/L
    '''
    x1 = pole_pos[0]
    y1 = pole_pos[1]
    
    x2 = measurement_location[0]
    y2 = measurement_location[1]
    
    r_dist = (np.sqrt((x2-x1)**2 + (y2-y1)**2))
    return r_dist
   

##################################################################################################################
#%%
#Assigns disances to microbot from each pole to a variable
Left_Pole_Dist = r_distance(Left_Pole_Origin, measurement_location)

Top_Pole_Dist = r_distance(Top_Pole_Origin, measurement_location)
Right_Pole_Dist = r_distance(Right_Pole_Origin, measurement_location)
Bottom_Pole_Dist = r_distance(Bottom_Pole_Origin, measurement_location)

#Assigns variable to NON normalizied direction vectors to microbot from each pole 
Left_Pole_Vector = r_vector(Left_Pole_Origin, measurement_location)/Left_Pole_Dist 
Top_Pole_Vector = r_vector(Top_Pole_Origin, measurement_location)/Top_Pole_Dist 
Right_Pole_Vector = r_vector(Right_Pole_Origin, measurement_location)/Right_Pole_Dist 
Bottom_Pole_Vector = r_vector(Bottom_Pole_Origin, measurement_location)/Bottom_Pole_Dist 

##################################################################################################################
#%%

#L Matrix Calculations, The L matrix describes positional graidents from poles to mbot
"""
L is a 4x4 matri,each item of which is a vector
"""



L_matrix = []



r_vect_j = [Left_Pole_Vector,Top_Pole_Vector,Right_Pole_Vector,Bottom_Pole_Vector]
r_vect_k = [Left_Pole_Vector,Top_Pole_Vector,Right_Pole_Vector,Bottom_Pole_Vector]


for j in r_vect_j:
    for k in r_vect_k:
        
        rdj = (np.linalg.norm(j))
        rdk = (np.linalg.norm(k))
        
        coef = 1/((rdj**3)*(rdk**3))
        
        Leftside = (1- (3*(np.dot(j,k))/(rdk**2)))*k
        Rightside = (1- (3*(np.dot(j,k))/(rdj**2)))*j
        
        Lindex = coef * (Leftside + Rightside)
        
        L_matrix.append(Lindex)
        
        
L_matrix_nump = np.array(L_matrix).reshape((4,4,2))

L_matrix_nump_X = L_matrix_nump[:,:,0]
L_matrix_nump_Y = L_matrix_nump[:,:,1]
##################################################################################################################
#%%




##################################################################################################################
#%%
#F Matrix Calculations, TThe magnetic force on the magnetic bead 
"""
F = (kq) * Fq_vect

where Fq_vect  = Q.transpose *L * Q

the magnetic force is nonlinear with respect 
to the magnetic charge vector Q and is position dependent, as suggested by matrix L.
"""



KI_matrix = np.array([[3/4, -1/4, -1/4, -1/4],  #matrix KI is the distribution matrix of the magnetic flux.
              [-1/4, 3/4, -1/4, -1/4],
              [-1/4, -1/4, 3/4, -1/4],
              [-1/4, -1/4, -1/4, 3/4]])

I_matrix = np.array([ILeft,ITop,IRight,IBottom])


Q_Matric_Const = (NTurns/(perm0*reluctance))
Qmatrix = Q_Matric_Const * np.matmul(KI_matrix , I_matrix)


#ISSUE: the comps of the force vector will always be positive. because we mulitmpy IxI. 
#actually this makes sense and is fine
FQx = np.matmul(np.matmul(Qmatrix,   L_matrix_nump_X) , Qmatrix.transpose())
FQy = np.matmul(np.matmul(Qmatrix,   L_matrix_nump_Y) , Qmatrix.transpose())

Fx  = FQx * kQ
Fy =  FQy * kQ


print("ForceX = ", Fx*(1/pico))
print("ForceY = ", Fy)
##################################################################################################################
#%%












##################################################################################################################
#%%
#plot microbot
plt.scatter(measurement_location[0],measurement_location[1],s=100,facecolors = "k")


    
#plot the vectors from each pole to microbot    
plt.quiver(Left_Pole_Origin[0],Left_Pole_Origin[1] ,Left_Pole_Vector[0] , Left_Pole_Vector[1],color='r', scale = None)
plt.quiver(Top_Pole_Origin[0],Top_Pole_Origin[1] ,Top_Pole_Vector[0] , Top_Pole_Vector[1],color='b',scale = None)
plt.quiver(Right_Pole_Origin[0],Right_Pole_Origin[1] ,Right_Pole_Vector[0] , Right_Pole_Vector[1],color='g',scale = None)
plt.quiver(Bottom_Pole_Origin[0],Bottom_Pole_Origin[1] ,Bottom_Pole_Vector[0] , Bottom_Pole_Vector[1],color='y',scale = None)

#plot force vector
plt.quiver(measurement_location[0],measurement_location[1] ,Fx, Fy,color='k', scale = None)

#plt.quiver(Left_Pole_Origin, V[0], V[1], color=['r','b','g'])
plt.xlim(-(Pole_Pole_Distance/2),(Pole_Pole_Distance/2))
plt.ylim(-(Pole_Pole_Distance/2),(Pole_Pole_Distance/2))
plt.xlabel("X (m)")
plt.ylabel("Y (m)")

plt.show()

      