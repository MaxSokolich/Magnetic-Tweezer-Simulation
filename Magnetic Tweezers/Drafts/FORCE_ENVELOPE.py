#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun Nov 14 12:07:34 2021

##########
from progress.bar import Bar
###########

@author: bizzaro
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sat Nov 13 13:42:40 2021

@author: bizzaro
"""
'''
issues:
    
we need ki = 0.35 for the values in the paper but Im getting 33. if I change reluctance to 10^10 instead of 10^ 9 were good
'''

'''
MAGNETIC FORCE ANALYSIS / MAGNETIC MONOPOLE APPROXIMATION / LUMPED-ELEMENT MODEL

    The lumped-element model (also called lumped-parameter model, or 
    lumped-component model) simplifies the description of the 
    behaviour of spatially distributed physical systems into
    a topology consisting of discrete entities that approximate 
    the behaviour of the distributed system under certain assumptions.
    It is useful in electrical systems (including electronics), 
    mechanical multibody systems, heat transfer, acoustics, etc.

    When viewing magnetic poles of the tweezers from the workspace, 
    they are sharp tips and generate a magnetic field that looks to 
    the magnetic particle as though it is generated by point sources. 
    Magnetic monopole approximation [25], [30] is there- fore employed 
    in this analysis to model the magnetic field gen- erated by the 
    quadrupole magnetic tweezers in the workspace. In this model, 
    the magnetic field generated by each magnetic pole is approximated 
    by the field of a point magnetic charge associated with the magnetic 
    pole, and the total magnetic field produced by the system is obtained 
    by applying the principle of superposition. Although a magnetic monopole 
    is a hypothetical point source, this approximation greatly simplifies the 
    process of modeling and yields an expression of the magnetic field in 
    the workspace similar to that of an electric field.More importantly,this 
    expression enables us later to derive a compact analytical force
    model that accurately characterizes the nonlinearity of the magnetic 
    force exerting on the magnetic particle with respect to the applied 
    currents to the coils and the position dependency of the magnetic 
    force in the workspace.

    When a magnetic particle is placed inside a magnetic field, 
    it will be magnetized, and in turn alter its surrounding magnetic field. 
    The magnetic force experienced by the magnetic particle is then determined 
    by the particle’s magnetization and the altered field. To calculate the 
    magnetic force using the original magnetic field, the effective magnetization 
    of the particle should be used. For a spherical par- ticle, 
    its effective magnetization is proportional to the external magnetic field [31] 
    until the magnetization saturates.
'''

import numpy as np
import matplotlib.pyplot as plt
import random as random

from tqdm import tqdm

    
    
plt.rcParams["figure.figsize"]=(8, 8)


milli = (10**(-3))
micro = (10**(-6))
nano = (10**(-9))
pico = (10**(-12))

perm0 = ((4*np.pi)*(10**(-7)))
    
#System Properties
Pole_Pole_Distance = 980 * micro                   # pole to pole distance in um, defines workspace area
L = (Pole_Pole_Distance/2)                         # length to center of workspace
Gradient_Space = (L/4)                             # Maximum gradient estimation distance 
I_max = .9                                         # Maximum current to avoid pole saturation --> value taken from paper
NTurns = 21                                        # number of turns on a single coil --> taken from paper
reluctance = (1.8*(10**9))                        # magnetic resitance of air gap --> value from paper 



#MICROSPHERE PROPERTIES
Bead_Diameter = (2.8 *micro)                       # bead diameter in micrometers
perm_bead = .0000375                               # neglected for force calculations: see "magnetic coeffceitns for why"
Volume = ((4/3)*np.pi*((Bead_Diameter/2)**3))      # volume of microsphere



#This wont really change anything
Air_AreaC = (0.18*milli*milli)                     # cross sectioal area of air gap 


#grid resolution of magnetic streamlines
gridp = 10


#DRAG FORCE INPUTS
viscosity = (8.90 * (10**(-4)))                    # Water Pa·s
velocity_X = (10)*micro                            # x veclity component of microsphere
velocity_Y = (0)*micro 




measurement_location = [200*micro,100*micro]






'''
To characterize the anisotropy of force generation, 
a measure Γ is defined as the ratio between the smallest 
magnitude and the largest magnitude on the force envelope. 
It is evident that Γ has the largest value, 0.7, at the center 
point and decreases while approaching each of the four poles. 
Fig. 7 shows the contour of Γ. It can be seen that Γ decreases 
rapidly when the magnetic particle moves from the center toward a
 magnetic pole. When Γ is too small, it may not be practically 
 possible to generate the desired force in the weakest force 
 direction due to various uncertainties of the system, such as 
 assembly errors of the tweezers and fluctuations of the commanded 
 currents. It is therefore important to limit the workspace to be within the 
 region where Γ > 0.1 for effective manipulation.
'''
FXX = []
FYY = []
current2 = np.linspace(0,1,10000)
for j in tqdm(range(len(current2))):
      
    

  
    
    
    ILeft = random.choice(current2)                                           # Applied current to left coil/pole in Amps
    ITop = random.choice(current2)                                         # Applied current to top coil/pole in Amps
    IRight = random.choice(current2)                                        # Applied current to right coil/pole in Amps
    IBottom = random.choice(current2)                                         # Applied current to bottom coil/pole in Amps          
                   
    

    
    ##################################################################################################################
    # %%
    #MAGNETIC COEFFICIENTS
    #print("##################################################################################################################")
    #print(                                        "MAGNETIC COEFFICENTS \n")
    '''
    ji_hat is basically the force gain and is mulitply my the direction because the magnetic force is dependent on L matrix or where the particle is
    As the magnetic probe is much more magnetic permeable than air, (μ − μ0 )/(μ + 2μ0 ) ~ 1
    
    '''
    
    Perm_coef = 1#((perm_bead - perm0)/(perm_bead + (2*perm0)))
    
    km = (perm0/(4*np.pi))
    kQ = ((3*Volume*(km**2))/(2*perm0*(L**5))) * Perm_coef #coefficient related to the properties of the magnetic particle and themagnetic tweezers
    ki = (kQ * ((NTurns/(perm0*reluctance))**2)) #lumped coefficent related to the particle and magnetic curcuit properites
    ki_hat = (ki * (I_max**2))
    
    
    #print("Ki = ", ki)
    #print("Ki_hat = ", ki_hat*(1/pico),"pN\n\n")
    ##################################################################################################################
    #%%
    
    
    
    
    
    
    
    
    
    
    
    ##################################################################################################################
    # %%
    #VECTOR FORMULATION
     
    Left_Pole_Origin = [-Pole_Pole_Distance/2,0]
    Top_Pole_Origin = [0,Pole_Pole_Distance/2]
    Right_Pole_Origin = [Pole_Pole_Distance/2,0]
    Bottom_Pole_Origin = [0,-Pole_Pole_Distance/2]
    
    def r_vector(Pole_Location, measurement_location):
        '''
        returns a 2D array fector in direction of microbot from desired pole
        '''
        x1 = Pole_Location[0]
        y1 = Pole_Location[1]
        
        x2 = measurement_location[0]
        y2 = measurement_location[1]
        r_vector = np.array([(x2-x1),(y2-y1)])
     
        return r_vector
    
    def r_distance(Pole_Location, measurement_location):
        '''
        returns a scalar distance desired pole to microbot
        not the normalized sistance r/L
        '''
        x1 = Pole_Location[0]
        y1 = Pole_Location[1]
        
        x2 = measurement_location[0]
        y2 = measurement_location[1]
        
        r_dist = (np.sqrt((x2-x1)**2 + (y2-y1)**2))
        return r_dist
    
    #Assigns disances to microbot from each pole to a variable
    Left_Pole_Dist = r_distance(Left_Pole_Origin, measurement_location)
    Top_Pole_Dist = r_distance(Top_Pole_Origin, measurement_location)
    Right_Pole_Dist = r_distance(Right_Pole_Origin, measurement_location)
    Bottom_Pole_Dist = r_distance(Bottom_Pole_Origin, measurement_location)
    
    #Assigns direction to microbot from each pole to a variable
    Left_Pole_Vector = r_vector(Left_Pole_Origin, measurement_location) 
    Top_Pole_Vector = r_vector(Top_Pole_Origin, measurement_location)
    Right_Pole_Vector = r_vector(Right_Pole_Origin, measurement_location)
    Bottom_Pole_Vector = r_vector(Bottom_Pole_Origin, measurement_location)
    ##################################################################################################################
    # %%
    

    
    
    
    ##################################################################################################################
    # %%
    #L MATRIX FORMULATION
    """
    L matrix calculation. Backbone of force directionality
    
    Bascially its the gradient of the dot product between each pole-bot vector sum(k x4) sum(i x 4) of (ui dot uk ) 
    
    
    NEED TO ADD FUNCTION THAT DOES THIS FOR EACH VECTOR: r_vect_j_hat = r_vect_j/r_dist
    
    """
    L_matrix = []
    
    r_dist = [Left_Pole_Dist,Top_Pole_Dist,Right_Pole_Dist,Bottom_Pole_Dist]
    
    r_vect_j = [Left_Pole_Vector,Top_Pole_Vector,Right_Pole_Vector,Bottom_Pole_Vector]
    r_vect_k = [Left_Pole_Vector,Top_Pole_Vector,Right_Pole_Vector,Bottom_Pole_Vector]
    
    #r_vect_j_hat = r_vect_j/r_dist
    
    for j in range(len(r_vect_j)):
        for k in range(len(r_vect_k)):
            
            
            
            r_dist_hat_j = (np.linalg.norm(r_vect_j[j]))/L
            r_dist_hat_k = (np.linalg.norm(r_vect_k[k]))/L
            
            coef = 1/((r_dist_hat_j**3)*(r_dist_hat_k**3))
            
            
            '''
            replace Left_Pole_Dist with r_dist[i]
            99.9% sure this is correct
            '''
            r_vect_hat_j = (r_vect_j[j]/r_dist[j])
            r_vect_hat_k = (r_vect_k[k]/r_dist[k])
            
            Leftside = (1- (3*(np.dot(r_vect_hat_j  ,r_vect_hat_k))/(r_dist_hat_k**2)))*r_vect_hat_k 
            Rightside = (1- (3*(np.dot(r_vect_hat_j  ,r_vect_hat_k))/(r_dist_hat_j**2)))*r_vect_hat_j 
            
           
            
            Lindex = coef * (Leftside + Rightside)
            
            L_matrix.append(Lindex)
            
            
    L_matrix_nump = np.array(L_matrix).reshape((4,4,2))
    
    L_matrix_nump_X = L_matrix_nump[:,:,0]
    L_matrix_nump_Y = L_matrix_nump[:,:,1]
    
    ##################################################################################################################
    # %%
    
    
    
    
    
 
    
    
    
    ##################################################################################################################
    # %%
    #N MATRIX FORMULATION 
    '''
    N_matrix calcualtions. N = KI_T  * L  *  KI
    KI matrix --> charge distributuons throughtout magnetic curcuit
    '''
    
    KI_matrix = np.array([[3/4, -1/4, -1/4, -1/4],  #matrix KI is the distribution matrix of the magnetic flux.
                  [-1/4, 3/4, -1/4, -1/4],
                  [-1/4, -1/4, 3/4, -1/4],
                  [-1/4, -1/4, -1/4, 3/4]])
    
    N_Matrix_X = np.matmul(np.matmul(KI_matrix.transpose() , L_matrix_nump_X), KI_matrix)
    N_Matrix_Y = np.matmul(np.matmul(KI_matrix.transpose() , L_matrix_nump_Y), KI_matrix)
    
    #print([N_Matrix_X,N_Matrix_Y])
    ##################################################################################################################
    #%%
    
    
    
    
    
    
    
    
    ##################################################################################################################
    
    
    #this force represents teh complete force model but does not consider magnetic pole saturation 
    I_matrix = np.array([ILeft,ITop,IRight,IBottom])
    
    Fx = ki * np.matmul(np.matmul(I_matrix, N_Matrix_X), I_matrix.transpose())
    Fy = ki * np.matmul(np.matmul(I_matrix, N_Matrix_Y), I_matrix.transpose())
    
    #print("F_MAG_X = ", Fx*(1/pico), "pN")
    #print("F_MAG_Y = ", Fy*(1/pico), "pN\n\n")
    
    FXX.append(Fx*(1/pico))
    FYY.append(Fy*(1/pico))
    
    ##################################################################################################################
    # %%
    
    
    
    
   
    
  

plt.figure()
plt.quiver(measurement_location[0],measurement_location[1],FXX,FYY)
plt.title("Force Envelope at %s"%([measurement_location[0]*(1/micro),measurement_location[1]*(1/micro)]))
plt.xlabel("FX")
plt.ylabel("FY")
plt.show()

















